(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[12],{

/***/ "./public/components/AAA.js":
/*!**********************************!*\
  !*** ./public/components/AAA.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*#container {\r\n  overflow: auto;\r\n  will-change: transform; /* make overflow fast on non-retina */\n\n/*padding: var(--default-padding);\r\nbackground-color: #ECEFF1;\r\nscroll-behavior: smooth;\r\n}*/\n\n/**\r\n * Sets up an intersection observer to notify when elements with the class\r\n * `.sticky_sentinel--top` become visible/invisible at the top of the container.\r\n */\nfunction observeHeaders(container) {\n  var observer = new IntersectionObserver(function (records, observer) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = records[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var record = _step.value;\n        var targetInfo = record.boundingClientRect;\n        var stickyTarget = record.target.parentElement.querySelector('.sticky');\n        var rootBoundsInfo = record.rootBounds;\n\n        if (targetInfo.bottom < rootBoundsInfo.top) {//    fire(true, stickyTarget);\n        }\n\n        if (targetInfo.bottom >= rootBoundsInfo.top && targetInfo.bottom < rootBoundsInfo.bottom) {//     fire(false, stickyTarget);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }, {\n    // rootMargin: '-16px',\n    threshold: [0],\n    root: container\n  }); // Add the bottom sentinels to each section and attach an observer.\n  //  const sentinels = addSentinels(container, 'sticky_sentinel--top');\n  //  sentinels.forEach(el => observer.observe(el));\n}\n/**\r\n * Sets up an intersection observer to notify when elements with the class\r\n * `.sticky_sentinel--bottom` become visible/invisible at the botton of the\r\n * container.\r\n */\n\n\nfunction observeFooters(container) {\n  var observer = new IntersectionObserver(function (records, observer) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = records[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var record = _step2.value;\n        var targetInfo = record.boundingClientRect;\n        var stickyTarget = record.target.parentElement.querySelector('.sticky');\n        var rootBoundsInfo = record.rootBounds;\n        var ratio = record.intersectionRatio;\n\n        if (targetInfo.bottom > rootBoundsInfo.top && ratio === 1) {//      fire(true, stickyTarget);\n        }\n\n        if (targetInfo.top < rootBoundsInfo.top && targetInfo.bottom < rootBoundsInfo.bottom) {//      fire(false, stickyTarget);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }, {\n    // rootMargin: '16px',\n    // Get callback slightly before element is 100% visible/invisible.\n    threshold: [1],\n    root: container\n  }); // Add the bottom sentinels to each section and attach an observer.\n  //  const sentinels = addSentinels(container, 'sticky_sentinel--bottom');\n  //  sentinels.forEach(el => observer.observe(el));\n}\n/**\r\n * Notifies when elements that have the class `sticky` begin to stick or not.\r\n * Note: these should be children of the `container` element.\r\n */\n\n\nfunction notifyWhenStickyHeadersChange(container) {\n  observeHeaders(container);\n  observeFooters(container);\n}\n\nvar container = document.querySelector('#container');\nnotifyWhenStickyHeadersChange(container);\ndocument.addEventListener('sticky-change', function (e) {\n  // Update sticking header title.\n  var _ref = [e.detail.target, e.detail.stuck],\n      header = _ref[0],\n      stuck = _ref[1];\n  header.classList.toggle('isPinned', stuck);\n});\n\n//# sourceURL=webpack:///./public/components/AAA.js?");

/***/ })

}]);